<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Laboratorio de Configuración Electrónica — Modo Práctica</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans'; }
    .orbital-box { transition: background-color .2s ease, box-shadow .2s ease, transform .12s ease; }
    .arrow { line-height: 1; font-weight: 700; user-select: none; }
    .badge { font-size: 10px; padding: 0 6px; border-radius: 999px; }
    .hint { font-size: 11px; }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-800">
  <!-- Header -->
  <header class="w-full border-b border-slate-200 bg-white sticky top-0 z-20">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex items-center justify-between">
      <div class="flex items-center gap-3">
        <div class="h-9 w-9 rounded-xl bg-gradient-to-br from-indigo-500 to-sky-600 grid place-items-center text-white font-extrabold">e⁻</div>
        <h1 class="text-xl sm:text-2xl font-bold tracking-tight">Laboratorio de Configuración Electrónica</h1>
      </div>
      <div class="text-xs text-slate-500">Z = 1–36 (Kr)</div>
    </div>
  </header>

  <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 grid grid-cols-1 xl:grid-cols-12 gap-6">
    <!-- Panel de control -->
    <aside class="xl:col-span-3 bg-white border border-slate-200 rounded-2xl shadow-sm p-4 sm:p-5">
      <h2 class="text-lg font-semibold mb-4">Panel de Control</h2>
      <div class="space-y-5">
        <div>
          <label for="zRange" class="block text-sm font-medium text-slate-700 mb-1">Número atómico (Z)</label>
          <div class="flex items-center gap-3">
            <input id="zRange" type="range" min="1" max="36" value="8" class="flex-1">
            <input id="zInput" type="number" min="1" max="36" value="8" class="w-20 rounded-lg border border-slate-300 px-2 py-1 text-center" />
          </div>
        </div>

        <div class="flex flex-col gap-2">
          <div class="flex items-center justify-between">
            <button id="animateBtn" class="inline-flex items-center gap-2 rounded-xl border border-slate-300 bg-white px-3 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-[.99]">
              ▶ Animar llenado
            </button>
            <label class="inline-flex items-center gap-2 text-sm">
              <input id="exceptionsToggle" type="checkbox" class="rounded border-slate-300"> 
              Excepciones (Cr, Cu)
            </label>
          </div>
          <label class="inline-flex items-center gap-2 text-sm">
            <input id="practiceToggle" type="checkbox" class="rounded border-slate-300"> 
            Modo práctica (llenado manual)
          </label>
        </div>

        <div id="ruleFeedback" class="text-sm text-slate-700 bg-slate-50 border border-slate-200 rounded-xl p-3">
          Listo: podés animar o activar el modo práctica para completar a mano.
        </div>

        <div id="exceptionsNote" class="hidden text-xs text-slate-700 bg-amber-50 border border-amber-200 rounded-xl p-3">
          Con excepciones: Cr (Z=24) ≈ [Ar] 3d⁵ 4s¹ y Cu (Z=29) ≈ [Ar] 3d¹⁰ 4s¹ (estabilización por subniveles semillenos/llenos).
        </div>

        <div id="practiceHelp" class="hidden hint text-slate-600 bg-slate-50 border border-slate-200 rounded-xl p-3">
          <div class="font-semibold mb-1">Controles en práctica:</div>
          <ul class="list-disc pl-5 space-y-1">
            <li>Click en la mitad superior de una casilla: agrega <span class="text-sky-700 font-semibold">↑</span>.</li>
            <li>Click en la mitad inferior: agrega <span class="text-rose-700 font-semibold">↓</span>.</li>
            <li><span class="underline">Click derecho</span> sobre mitad superior/inferior: quita una flecha de ese tipo.</li>
            <li>Se permite sobrecargar (más de 2 e⁻) para evaluar errores; aparecerá un badge <span class="badge bg-amber-100 text-amber-700 border border-amber-300">+n</span>.</li>
          </ul>
        </div>

        <div class="grid grid-cols-3 gap-2">
          <button id="verifyBtn" class="rounded-xl border border-emerald-300 bg-emerald-50 px-3 py-2 text-sm font-medium text-emerald-800 hover:bg-emerald-100">Verificar</button>
          <button id="showSolutionBtn" class="rounded-xl border border-indigo-300 bg-indigo-50 px-3 py-2 text-sm font-medium text-indigo-800 hover:bg-indigo-100">Mostrar solución</button>
          <button id="clearPracticeBtn" class="rounded-xl border border-slate-300 bg-white px-3 py-2 text-sm font-medium hover:bg-slate-50">Limpiar</button>
        </div>
      </div>

      <div class="mt-4 text-[11px] text-slate-500">
        Leyenda: <span class="inline-block align-middle h-3 w-3 rounded ring-2 ring-rose-400 bg-rose-50 mr-1"></span>Pauli/Capacidad, 
        <span class="inline-block align-middle h-3 w-3 rounded ring-2 ring-amber-400 bg-amber-50 mx-1"></span>Aufbau, 
        <span class="inline-block align-middle h-3 w-3 rounded ring-2 ring-fuchsia-400 bg-fuchsia-50 mx-1"></span>Difiere de la solución.
      </div>
    </aside>

    <!-- Diagrama de orbitales -->
    <section class="xl:col-span-6 bg-white border border-slate-200 rounded-2xl shadow-sm p-4 sm:p-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold">Diagrama de orbitales (Aufbau)</h2>
        <span class="text-xs text-slate-500">Orden: 1s, 2s, 2p, 3s, 3p, 4s, 3d, 4p</span>
      </div>
      <div id="diagram" class="grid gap-3 sm:gap-4"></div>
    </section>

    <!-- Panel de resultados -->
    <aside class="xl:col-span-3 bg-white border border-slate-200 rounded-2xl shadow-sm p-4 sm:p-5" aria-live="polite">
      <h2 class="text-lg font-semibold mb-4">Resultados</h2>
      <div class="space-y-4">
        <div class="border border-slate-200 rounded-xl p-3">
          <div class="text-sm text-slate-500 mb-1">Configuración completa</div>
          <div id="configFull" class="text-base font-semibold break-words">—</div>
        </div>
        <div class="border border-slate-200 rounded-xl p-3">
          <div class="text-sm text-slate-500 mb-1">Configuración abreviada (kernel)</div>
          <div id="configKernel" class="text-base font-semibold break-words">—</div>
        </div>
        <div class="border border-slate-200 rounded-xl p-3">
          <div class="text-sm text-slate-500 mb-1">Electrones de valencia</div>
          <div id="valence" class="text-base font-semibold">—</div>
        </div>
        <div class="border border-slate-200 rounded-xl p-3">
          <div class="text-sm text-slate-500 mb-1">Clasificación del último electrón</div>
          <div id="block" class="text-base font-semibold">—</div>
        </div>
        <div id="diagnostics" class="border border-slate-200 rounded-xl p-3 text-sm text-slate-700 bg-slate-50 hidden"></div>
      </div>
    </aside>
  </main>

  <footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-8">
    <div class="text-xs text-slate-500">Consejo: en práctica se permite cometer errores para aprender. Luego usá “Verificar” para obtener retroalimentación específica por regla.</div>
  </footer>

  <script>
    // --------------------- Modelo de orbitales ---------------------
    const SUBLEVELS = [
      { label: '1s', n:1, type:'s', orbitals:1 },
      { label: '2s', n:2, type:'s', orbitals:1 },
      { label: '2p', n:2, type:'p', orbitals:3 },
      { label: '3s', n:3, type:'s', orbitals:1 },
      { label: '3p', n:3, type:'p', orbitals:3 },
      { label: '4s', n:4, type:'s', orbitals:1 },
      { label: '3d', n:3, type:'d', orbitals:5 },
      { label: '4p', n:4, type:'p', orbitals:3 },
    ];

    const MAX_Z = 36; // Kr

    // --------------------- Estado ---------------------
    const state = {
      Z: 8,
      exceptions: false,
      practice: false,
      animating: false,
      filling: null, // matriz [{up:int,down:int}]
    };

    const byId = id => document.getElementById(id);
    const sleep = ms => new Promise(r => setTimeout(r, ms));

    // --------------------- Utilidades de kernel ---------------------
    function nobleKernel(Z){
      if (Z >= 36) return { symbol: 'Kr', Z: 36 };
      if (Z >= 18) return { symbol: 'Ar', Z: 18 };
      if (Z >= 10) return { symbol: 'Ne', Z: 10 };
      if (Z >= 2) return { symbol: 'He', Z: 2 };
      return { symbol: '', Z: 0 };
    }

    // --------------------- Construcción de estructuras ---------------------
    function emptyFilling(){
      return SUBLEVELS.map(sl => Array(sl.orbitals).fill(0).map(()=>({up:0, down:0})));
    }

    function cloneFilling(f){ return f.map(sl => sl.map(o => ({up:o.up, down:o.down}))); }

    // Relleno instantáneo ideal (Aufbau + Hund + Pauli)
    function fillElectronsInstant(Z){
      const filling = emptyFilling();
      let remaining = Z;
      for (const [si, sl] of SUBLEVELS.entries()){
        if (remaining <= 0) break;
        const capacity = sl.orbitals * 2;
        const use = Math.min(capacity, remaining);
        let placed = 0;
        // Hund
        for (let i=0; i<sl.orbitals && placed<use; i++){ filling[si][i].up++; placed++; }
        // Pauli
        for (let i=0; i<sl.orbitals && placed<use; i++){ filling[si][i].down++; placed++; }
        remaining -= use;
      }
      return filling;
    }

    function setSublevel(fillStruct, label, orbitals){
      const idx = SUBLEVELS.findIndex(s => s.label === label);
      if (idx>=0) fillStruct[idx] = orbitals;
    }

    function applyExceptions(Z, filling){
      if (!state.exceptions) return filling;
      const f = cloneFilling(filling);
      if (Z === 24) { // Cr: [Ar] 3d5 4s1
        setSublevel(f, '4s', [ {up:1,down:0} ]);
        setSublevel(f, '3d', Array(5).fill(0).map(()=>({up:1,down:0})));
      }
      if (Z === 29) { // Cu: [Ar] 3d10 4s1
        setSublevel(f, '4s', [ {up:1,down:0} ]);
        setSublevel(f, '3d', Array(5).fill(0).map(()=>({up:1,down:1})));
      }
      return f;
    }

    // --------------------- Texto de configuración ---------------------
    function superscript(n){
      const map = {'0':'⁰','1':'¹','2':'²','3':'³','4':'⁴','5':'⁵','6':'⁶','7':'⁷','8':'⁸','9':'⁹'};
      return String(n).split('').map(d=>map[d]||d).join('');
    }

    function configFromFilling(filling){
      const parts = [];
      SUBLEVELS.forEach((sl, si) => {
        const electrons = filling[si].reduce((acc,o)=>acc+o.up+o.down,0);
        if (electrons>0){ parts.push(`${sl.label}${superscript(electrons)}`); }
      });
      return parts.join(' ');
    }

    function kernelConfig(Z, filling){
      const kernel = nobleKernel(Z);
      if (!kernel.symbol) return configFromFilling(filling);
      if (kernel.Z === Z) return `[${kernel.symbol}]`;
      let remaining = Z - kernel.Z;
      const parts = [];
      for (const sl of SUBLEVELS){
        if (remaining <= 0) break;
        const cap = sl.orbitals*2;
        const use = Math.min(cap, remaining);
        if (use>0) parts.push(`${sl.label}${superscript(use)}`);
        remaining -= use;
      }
      return `[${kernel.symbol}] ` + parts.join(' ');
    }

    function valenceCount(filling){
      let maxN = 0;
      SUBLEVELS.forEach((sl, si) => {
        const e = filling[si].reduce((a,o)=>a+o.up+o.down,0);
        if (e>0) maxN = Math.max(maxN, sl.n);
      });
      let val = 0;
      SUBLEVELS.forEach((sl, si) => { if (sl.n === maxN) val += filling[si].reduce((a,o)=>a+o.up+o.down,0); });
      return val;
    }

    function lastElectronBlock(filling){
      for (let si=SUBLEVELS.length-1; si>=0; si--){
        const e = filling[si].reduce((a,o)=>a+o.up+o.down,0);
        if (e>0) return SUBLEVELS[si].type.toUpperCase();
      }
      return '—';
    }

    // --------------------- Render del diagrama ---------------------
    const diagram = byId('diagram');

    function renderDiagramContainers(){
      diagram.innerHTML = '';
      SUBLEVELS.forEach((sl) => {
        const row = document.createElement('div');
        row.className = 'grid items-center gap-2 sm:gap-3';
        row.style.gridTemplateColumns = 'auto 1fr';

        const label = document.createElement('div');
        label.className = 'text-sm sm:text-base font-semibold text-slate-700 w-16';
        label.textContent = sl.label;
        row.appendChild(label);

        const boxes = document.createElement('div');
        boxes.className = 'flex flex-wrap gap-2';
        boxes.dataset.label = sl.label;

        for (let i=0;i<sl.orbitals;i++){
          const box = document.createElement('div');
          box.className = 'orbital-box relative h-14 w-16 sm:h-16 sm:w-20 rounded-xl border border-slate-300 bg-white grid grid-rows-2 place-items-center select-none';
          box.dataset.sl = sl.label; box.dataset.oi = i;
          // Up/Down containers
          const up = document.createElement('div'); up.className = 'arrow text-sky-700'; up.textContent = '';
          const down = document.createElement('div'); down.className = 'arrow text-rose-700'; down.textContent = '';
          // Badges extra
          const badgeUp = document.createElement('div'); badgeUp.className = 'badge absolute top-1 right-1 bg-sky-100 text-sky-800 border border-sky-300 hidden'; badgeUp.textContent = '+0';
          const badgeDown = document.createElement('div'); badgeDown.className = 'badge absolute bottom-1 right-1 bg-rose-100 text-rose-800 border border-rose-300 hidden'; badgeDown.textContent = '+0';
          box.append(up, down, badgeUp, badgeDown);

          // Interacción práctica
          box.addEventListener('click', (ev) => {
            if (!state.practice) return;
            const rect = box.getBoundingClientRect();
            const midY = rect.top + rect.height/2;
            const which = (ev.clientY < midY) ? 'up' : 'down';
            const si = SUBLEVELS.findIndex(s=>s.label===sl.label); const oi = i;
            state.filling[si][oi][which]++;
            updateDiagram(state.filling); updateResults(state.Z, state.filling);
          });
          box.addEventListener('contextmenu', (ev) => {
            if (!state.practice) return;
            ev.preventDefault();
            const rect = box.getBoundingClientRect();
            const midY = rect.top + rect.height/2;
            const which = (ev.clientY < midY) ? 'up' : 'down';
            const si = SUBLEVELS.findIndex(s=>s.label===sl.label); const oi = i;
            state.filling[si][oi][which] = Math.max(0, state.filling[si][oi][which]-1);
            updateDiagram(state.filling); updateResults(state.Z, state.filling);
          });

          boxes.appendChild(box);
        }
        row.appendChild(boxes);
        diagram.appendChild(row);
      });
    }

    function updateDiagram(filling, highlights){
      SUBLEVELS.forEach((sl, si) => {
        const rowBoxes = diagram.querySelector(`[data-label="${sl.label}"]`);
        if (!rowBoxes) return;
        const children = Array.from(rowBoxes.children);
        filling[si].forEach((occ, oi) => {
          const box = children[oi];
          const [upEl, downEl, badgeUp, badgeDown] = box.children;
          // Render flechas repetidas (máx 3 visibles por tipo) y badges para extra
          upEl.textContent = '↑'.repeat(Math.min(occ.up, 3));
          downEl.textContent = '↓'.repeat(Math.min(occ.down, 3));
          const extraUp = Math.max(0, occ.up - 1); // >1 ya es extra para Pauli
          const extraDown = Math.max(0, occ.down - 1);
          if (extraUp>0){ badgeUp.textContent = '+'+extraUp; badgeUp.classList.remove('hidden'); } else badgeUp.classList.add('hidden');
          if (extraDown>0){ badgeDown.textContent = '+'+extraDown; badgeDown.classList.remove('hidden'); } else badgeDown.classList.add('hidden');

          // Limpia resaltados
          box.classList.remove('ring-2','ring-rose-400','ring-amber-400','ring-fuchsia-400','bg-rose-50','bg-amber-50','bg-fuchsia-50');

          if (highlights && highlights[si] && highlights[si][oi]){
            const h = highlights[si][oi];
            if (h.pauli || h.capacity){ box.classList.add('ring-2','ring-rose-400','bg-rose-50'); }
            if (h.aufbau){ box.classList.add('ring-2','ring-amber-400','bg-amber-50'); }
            if (h.diff){ box.classList.add('ring-2','ring-fuchsia-400','bg-fuchsia-50'); }
          }
        });
      });
    }

    // --------------------- Resultados ---------------------
    const configFullEl = byId('configFull');
    const configKernelEl = byId('configKernel');
    const valenceEl = byId('valence');
    const blockEl = byId('block');

    function updateResults(Z, filling){
      const adjusted = applyExceptions(Z, filling);
      configFullEl.textContent = configFromFilling(adjusted) || '—';
      configKernelEl.textContent = kernelConfig(Z, adjusted);
      valenceEl.textContent = valenceCount(adjusted);
      blockEl.textContent = lastElectronBlock(adjusted);
    }

    // --------------------- Verificación ---------------------
    const diagnosticsEl = byId('diagnostics');

    function verifyPractice(){
      const Z = state.Z;
      const correct = applyExceptions(Z, fillElectronsInstant(Z));
      const user = cloneFilling(state.filling);

      const highlights = SUBLEVELS.map(sl => Array(sl.orbitals).fill(0).map(()=>({}))); // marca por casilla
      const issues = [];

      // Conteo total
      const eUser = user.flat().reduce((a,o)=>a+o.up+o.down,0);
      if (eUser !== Z){ issues.push(`Conteo total: colocaste ${eUser} e⁻, deberían ser ${Z}.`); }

      // Pauli y capacidad
      SUBLEVELS.forEach((sl, si) => {
        user[si].forEach((o, oi) => {
          if (o.up>1 || o.down>1){ highlights[si][oi].pauli = true; }
          if ((o.up+o.down)>2){ highlights[si][oi].capacity = true; }
        });
      });
      if (highlights.flat().some(h=>h.pauli)){ issues.push('Principio de Pauli: hay orbitales con más de una flecha ↑ o ↓.'); }
      if (highlights.flat().some(h=>h.capacity)){ issues.push('Capacidad: hay orbitales con más de 2 e⁻.'); }

      // Hund: si hay ↓ en un subnivel p/d mientras exista una caja vacía sin ↑
      SUBLEVELS.forEach((sl, si) => {
        if (sl.orbitals>1){
          const hasDown = user[si].some(o=>o.down>0);
          const emptyNoUp = user[si].some(o=>o.up===0);
          if (hasDown && emptyNoUp){
            issues.push(`Regla de Hund en ${sl.label}: se apareó antes de maximizar espines paralelos.`);
            // resaltar todas las cajas apareadas y las vacías sin ↑
            user[si].forEach((o, oi)=>{
              if (o.down>0) highlights[si][oi].diff = true;
              if (o.up===0) highlights[si][oi].diff = true;
            });
          }
        }
      });

      // Aufbau: comparar contra distribución correcta por subnivel
      SUBLEVELS.forEach((sl, si) => {
        const u = user[si].reduce((a,o)=>a+o.up+o.down,0);
        const c = correct[si].reduce((a,o)=>a+o.up+o.down,0);
        if (u>c){ // exceso aquí
          issues.push(`Aufbau: exceso de e⁻ en ${sl.label} respecto de la configuración esperada.`);
          user[si].forEach((o,oi)=>{ if (o.up+o.down>correct[si][oi].up+correct[si][oi].down) highlights[si][oi].aufbau = true; });
        }
      });
      // Además, si hay subniveles posteriores con e⁻ y alguno anterior aún no completo
      let firstIncomplete = -1;
      SUBLEVELS.forEach((sl, si) => {
        const c = correct[si].reduce((a,o)=>a+o.up+o.down,0);
        const u = user[si].reduce((a,o)=>a+o.up+o.down,0);
        if (firstIncomplete===-1 && u<c) firstIncomplete = si;
      });
      if (firstIncomplete>=0){
        for (let j=firstIncomplete+1; j<SUBLEVELS.length; j++){
          const uLater = user[j].reduce((a,o)=>a+o.up+o.down,0);
          if (uLater>0){
            issues.push('Aufbau: hay electrones en subniveles de mayor energía con subniveles previos aún incompletos.');
            user[j].forEach((o,oi)=>{ if (o.up+o.down>0) highlights[j][oi].aufbau = true; });
            break;
          }
        }
      }

      // Diferencias respecto de la solución final
      SUBLEVELS.forEach((sl, si) => {
        user[si].forEach((o, oi) => {
          if ((o.up!==correct[si][oi].up) || (o.down!==correct[si][oi].down)){
            highlights[si][oi].diff = highlights[si][oi].diff || true;
          }
        });
      });

      updateDiagram(user, highlights);

      // Armar diagnóstico
      diagnosticsEl.classList.remove('hidden');
      diagnosticsEl.innerHTML = issues.length ? ('<ul class="list-disc pl-5 space-y-1">'+issues.map(t=>`<li>${t}</li>`).join('')+'</ul>') : '<span class="text-emerald-700 font-medium">¡Excelente! Cumple Aufbau, Pauli y Hund para Z = '+Z+'.</span>';
      ruleFeedback.textContent = 'Verificación completada.';
    }

    // --------------------- Animación ---------------------
    async function animateFilling(Z){
      if (state.animating || state.practice) return; // no animar en práctica
      state.animating = true;
      ruleFeedback.textContent = 'Iniciando: Regla de Aufbau (llenado por menor energía).';

      let filling = emptyFilling();
      updateDiagram(filling);
      updateResults(Z, filling);

      let remaining = Z;
      outer: for (const [si, sl] of SUBLEVELS.entries()){
        if (remaining <= 0) break;
        ruleFeedback.textContent = `Aufbau: llenando ${sl.label}.`;
        await sleep(250);

        const deg = sl.orbitals;
        const capacity = deg*2;
        const use = Math.min(capacity, remaining);

        if (deg > 1 && use > 1){ ruleFeedback.textContent = `Regla de Hund: maximizar espines paralelos en ${sl.label}.`; }
        for (let i=0; i<deg && i<use; i++){
          filling[si][i].up++; updateDiagram(filling); updateResults(Z, filling); await sleep(200);
          if (--remaining === 0) break outer;
        }

        if (use > deg){ ruleFeedback.textContent = `Principio de Pauli: apareando espines en ${sl.label}.`; }
        for (let i=0; i<deg && (deg + i)<use; i++){
          filling[si][i].down++; updateDiagram(filling); updateResults(Z, filling); await sleep(200);
          if (--remaining === 0) break outer;
        }
      }

      if (state.exceptions && (Z===24 || Z===29)){
        ruleFeedback.textContent = 'Aplicando excepción de estabilidad (Cr/Cu).';
        const adjusted = applyExceptions(Z, emptyFilling());
        updateDiagram(adjusted);
        updateResults(Z, adjusted);
      } else {
        ruleFeedback.textContent = 'Completado.';
      }

      state.animating = false;
    }

    // --------------------- Eventos UI ---------------------
    const zRange = byId('zRange');
    const zInput = byId('zInput');
    const animateBtn = byId('animateBtn');
    const exceptionsToggle = byId('exceptionsToggle');
    const exceptionsNote = byId('exceptionsNote');
    const practiceToggle = byId('practiceToggle');
    const practiceHelp = byId('practiceHelp');
    const verifyBtn = byId('verifyBtn');
    const showSolutionBtn = byId('showSolutionBtn');
    const clearPracticeBtn = byId('clearPracticeBtn');

    function setZ(val){
      const Z = Math.min(MAX_Z, Math.max(1, Number(val)||1));
      state.Z = Z; zRange.value = Z; zInput.value = Z;
      diagnosticsEl.classList.add('hidden');
      const base = fillElectronsInstant(Z);
      const maybeAdjusted = applyExceptions(Z, base);
      if (!state.practice){ state.filling = cloneFilling(maybeAdjusted); }
      updateDiagram(state.filling);
      updateResults(Z, state.filling);
      ruleFeedback.textContent = 'Listo: resultados actualizados. Usá “Animar” o activá “Modo práctica”.';
    }

    zRange.addEventListener('input', e => setZ(e.target.value));
    zInput.addEventListener('input', e => setZ(e.target.value));

    exceptionsToggle.addEventListener('change', e => {
      state.exceptions = e.target.checked;
      exceptionsNote.classList.toggle('hidden', !state.exceptions);
      setZ(state.Z);
    });

    practiceToggle.addEventListener('change', e => {
      state.practice = e.target.checked;
      diagnosticsEl.classList.add('hidden');
      practiceHelp.classList.toggle('hidden', !state.practice);
      if (state.practice){
        // Iniciar con vacío para que el estudiante llene
        state.filling = emptyFilling();
        ruleFeedback.textContent = 'Modo práctica activo: agregá ↑ o ↓ con el mouse. Luego presioná “Verificar”.';
      } else {
        // Volver a la configuración correcta instantánea
        const base = fillElectronsInstant(state.Z);
        state.filling = applyExceptions(state.Z, base);
        ruleFeedback.textContent = 'Modo práctica desactivado: vista en configuración correcta. Podés animar el proceso.';
      }
      updateDiagram(state.filling);
      updateResults(state.Z, state.filling);
    });

    animateBtn.addEventListener('click', () => animateFilling(state.Z));
    verifyBtn.addEventListener('click', () => { if (state.practice) verifyPractice(); });
    showSolutionBtn.addEventListener('click', () => {
      const sol = applyExceptions(state.Z, fillElectronsInstant(state.Z));
      state.filling = cloneFilling(sol);
      updateDiagram(state.filling);
      updateResults(state.Z, state.filling);
      diagnosticsEl.classList.add('hidden');
      ruleFeedback.textContent = 'Mostrando solución para Z = ' + state.Z + '.';
    });
    clearPracticeBtn.addEventListener('click', () => {
      if (!state.practice) return;
      state.filling = emptyFilling();
      diagnosticsEl.classList.add('hidden');
      updateDiagram(state.filling);
      updateResults(state.Z, state.filling);
      ruleFeedback.textContent = 'Práctica limpia: comenzá de nuevo.';
    });

    // --------------------- Init ---------------------
    renderDiagramContainers();
    state.filling = fillElectronsInstant(state.Z);
    updateDiagram(state.filling);
    updateResults(state.Z, state.filling);
  </script>
</body>
</html>
